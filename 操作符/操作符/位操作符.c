#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>


int main2_1()
{
	// & 按位（二进制）与        也只适用于整形
    // | 按位 或
	// ^ 按位异或

	int a = 3;   // 整形 四个字节 一个字节8位 32位 00000000000000000000000000000011
	int b = -5;  // 原码  10000000000000000000000000000101 
	             // 补码  11111111111111111111111111111011
	int c = a & b; // 与  00000000000000000000000000000011 为补码 原码相同
	                      
	 // %d打印有符号整数  
	printf("c=%d\n", c);
	return 0;
}



// 2.不能创建临时变量（第三个变量），实现两个数的交换。

int main2_21()   //法1 存在溢出问题 a b在范围内 a+b可能不在
{
	int a = 3;
	int b = 5;

	printf("交换前:a=%d b=%d\n", a, b);

	a = a + b;
	b = a - b;
	a = a - b;

	printf("交换后:a=%d b=%d\n", a, b);

	return 0;
 }



int main2_22()

{
		int a = 3;  // 011
		int b = 5;  // 101
		
		// 0 ^ a = a
		// a ^ a = 0

		// 3 ^ 3 ^ 5 = 0 ^ 5 = 5
		// 3 ^ 5 ^ 3 = 0 1 1 ^ 1 0 1 ^ 0 1 1 = 1 1 0 ^ 0 1 1 = 1 0 1 = 5
		// 因此异或支持交换律

		printf("交换前:a=%d b=%d\n", a, b);

		a = a ^ b;     //使用异或 异1同0
		b = a ^ b;     //  b = a^b^b = a^0 = a  -->  b=3
		a = a ^ b;    //  a = 3^5^3 = 5 交换完成

		// 且不会进位 不会溢出

		printf("交换后:a=%d b=%d\n", a, b);

		return 0;

}





// 3.编写代码实现：求一个整数存储在内存中的二进制中1的个数。(求补码中1的个数)


// 按位与1    0000 0011
//            0000 0001
//            0000 0001 

// 左移      0000 0011
//           0000 0010
//           0000 0010

int main000()
{



	return 0;
}






int main23132()
{
	int a = 13;   //   0000 1101   想改为 0001 1101
	              //   需要把第五位改成1(改1通过或1)   和 0001 0000 取或 |=
	              //   1 < < 4   00010000 

	// 如果想把这个1删掉 改回来
	//  ~按位取反 ~00010000 ――11101111 取0用与
	//  

	return 0;
}





// sizeof是操作符 strlen是函数

void test1(int arr[])
{
	printf("%d\n", sizeof(arr));//(2)  x86返回4  x64返回8  arr传来的是地址
}
void test2(char ch[])
{
	printf("%d\n", sizeof(ch));//(4)  x86 4     x64 8 
} 
int main1564165()
{
	int arr[10] = { 0 };
	char ch[10] = { 0 };
	printf("%d\n", sizeof(arr));//(1)  40 整形4 * 10
	printf("%d\n", sizeof(ch));//(3)  10 字符1*10
	test1(arr);
	test2(ch);
	return 0;
}


// if("abc" == "abcdef") 字符串比较不能这样写  这样写是比较首字符的地址

