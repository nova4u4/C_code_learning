#define _CRT_SECURE_NO_WARNINGS
/*
方法一：
思路：
循环进行以下操作，直到n被缩减为0：
   1. 用该数据模2，检测其是否能够被2整除
   2. 可以：则该数据对应二进制比特位的最低位一定是0，否则是1，如果是1给计数加1
   3. 如果n不等于0时，继续1
*/
int count_one_bit1(int n)
{
	int count = 0;
	while (n)
	{
		if (n % 2 == 1)
			count++;
		n = n / 2;
	}
	return count;
}


/*
上述方法缺陷：进行了大量的取模以及除法运算，取模和除法运算的效率本来就比较低。
方法二思路：
一个int类型的数据，对应的二进制一共有32个比特位，可以采用位运算的方式一位一位的检测，具体如下
*/
int count_one_bit2(unsigned int n)
{
	int count = 0;
	int i = 0;
	for (i = 0; i < 32; i++)
	{
		if (((n >> i) & 1) == 1)
			count++;
	}
	return count;
}


/*
方法二优点：用位操作代替取模和除法运算，效率稍微比较高
  缺陷：不论是什么数据，循环都要执行32次

方法三：
思路：采用相邻的两个数据进行按位与运算
举例：

10101  --10100 
         10011-- 10000
		         01111 ------00000  三个1循环三次


可以观察下：此种方式，数据的二进制比特位中有几个1，循环就循环几次，
而且中间采用了位运算，处理起来比较高效
*/
int count_one_bit3(int n)
{
	int count = 0;
	while (n)
	{
		n = n & (n - 1);
		count++;
	}
	return count;
}